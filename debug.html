<!DOCTYPE html>
<html>
<head>
  <title>Felt Debug v3</title>
  <style>
    body { font-family: system-ui; background: #1a1a2e; color: #eee; padding: 20px; }
    #map { width: 100%; height: 250px; border: 1px solid #444; margin-bottom: 15px; }
    pre { background: #0d0d1a; padding: 15px; border-radius: 8px; overflow: auto; max-height: 450px; font-size: 11px; }
    .success { color: #4ade80; }
    .error { color: #f87171; }
    .info { color: #60a5fa; }
    .warn { color: #fbbf24; }
    button { background: #6366f1; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin: 5px; }
    select, input { padding: 8px; border-radius: 6px; background: #2a2a3e; color: white; border: 1px solid #444; }
    .controls { margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
  </style>
</head>
<body>
  <h1>ğŸ”§ Felt Debug v3 - Verbose Logging</h1>
  
  <div class="controls">
    <input type="text" id="map-url" value="https://felt.com/map/Living-Earth-Animated-Pulse-Map-zH0ZvXraQTep7nfT1L4kSD" style="flex:1; min-width:300px;">
    <button onclick="loadMap()">Load Map</button>
  </div>
  
  <div id="map"></div>
  
  <div class="controls">
    <select id="layer-select"><option value="">Select layer...</option></select>
    <button onclick="runFullTest()">ğŸ§ª Run Full Analysis Test</button>
  </div>
  
  <pre id="output">Click "Load Map" to start...</pre>
  
  <script type="module">
    import { Felt } from "https://esm.run/@feltmaps/js-sdk";
    import * as turf from "https://esm.run/@turf/turf";
    
    let felt = null;
    const output = document.getElementById('output');
    
    function log(msg, type = '') {
      const div = document.createElement('div');
      div.className = type;
      div.textContent = msg;
      output.appendChild(div);
      output.scrollTop = output.scrollHeight;
    }
    
    function clear() { output.innerHTML = ''; }
    
    window.loadMap = async function() {
      clear();
      const url = document.getElementById('map-url').value;
      const match = url.match(/felt\.com\/map\/[^\/]+-([a-zA-Z0-9]+)/);
      const mapId = match ? match[1] : url;
      
      log(`Loading map: ${mapId}`, 'info');
      
      try {
        felt = await Felt.embed(document.getElementById('map'), mapId);
        log('âœ… Map loaded', 'success');
        
        const layers = await felt.getLayers();
        log(`Found ${layers.length} layers`);
        
        const select = document.getElementById('layer-select');
        select.innerHTML = '<option value="">Select layer...</option>';
        layers.forEach(l => {
          const opt = document.createElement('option');
          opt.value = l.id;
          opt.textContent = l.name || l.id;
          select.appendChild(opt);
        });
        
        log('\nâœ… Ready! Select a layer and click "Run Full Analysis Test"', 'success');
      } catch (e) {
        log(`âŒ Error: ${e.message}`, 'error');
      }
    };
    
    window.runFullTest = async function() {
      clear();
      const layerId = document.getElementById('layer-select').value;
      if (!layerId) { log('Select a layer first', 'error'); return; }
      
      log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
      log('    FULL ANALYSIS TEST - VERBOSE', 'info');
      log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n', 'info');
      
      // STEP 1: Get features
      log('STEP 1: Fetching features...', 'info');
      let rawFeatures;
      try {
        const result = await felt.getFeatures({ layerId });
        rawFeatures = result?.features || [];
        log(`  âœ… Got ${rawFeatures.length} raw features`, 'success');
      } catch (e) {
        log(`  âŒ getFeatures failed: ${e.message}`, 'error');
        return;
      }
      
      if (rawFeatures.length === 0) {
        log('  âŒ No features to analyze', 'error');
        return;
      }
      
      // Show first feature structure
      const first = rawFeatures[0];
      log(`\n  First feature structure:`, 'info');
      log(`    Keys: ${Object.keys(first).join(', ')}`);
      log(`    geometry: ${JSON.stringify(first.geometry)}`);
      log(`    geometryType: ${first.geometryType}`);
      
      // STEP 2: Normalize - extract geometry from properties
      log('\nSTEP 2: Normalizing geometries...', 'info');
      const normalized = [];
      
      for (let i = 0; i < rawFeatures.length; i++) {
        const f = rawFeatures[i];
        const props = f.properties || {};
        
        // Check if native geometry exists
        if (f.geometry && f.geometry.coordinates) {
          normalized.push(f);
          if (i === 0) log(`  Feature 0: Has native geometry`, 'success');
          continue;
        }
        
        // Extract from properties
        const latVal = props.latitude ?? props.lat ?? props.Latitude;
        const lngVal = props.longitude ?? props.lng ?? props.Longitude;
        
        if (i === 0) {
          log(`  Feature 0: No native geometry`);
          log(`    props.latitude = ${latVal} (${typeof latVal})`);
          log(`    props.longitude = ${lngVal} (${typeof lngVal})`);
        }
        
        if (latVal !== undefined && lngVal !== undefined) {
          const lat = Number(latVal);
          const lng = Number(lngVal);
          
          if (!isNaN(lat) && !isNaN(lng)) {
            const normalizedFeature = {
              id: f.id,
              properties: f.properties,
              geometry: {
                type: 'Point',
                coordinates: [lng, lat]
              }
            };
            normalized.push(normalizedFeature);
            
            if (i === 0) {
              log(`    Parsed: lat=${lat}, lng=${lng}`, 'success');
              log(`    Created geometry: ${JSON.stringify(normalizedFeature.geometry)}`, 'success');
            }
          } else {
            if (i === 0) log(`    âŒ Parse failed: lat=${lat}, lng=${lng}`, 'error');
          }
        } else {
          if (i === 0) log(`    âŒ No lat/lng found`, 'error');
        }
      }
      
      log(`\n  âœ… Normalized ${normalized.length} / ${rawFeatures.length} features`, 
          normalized.length > 0 ? 'success' : 'error');
      
      if (normalized.length === 0) {
        log('  âŒ No features with valid geometry', 'error');
        return;
      }
      
      // STEP 3: Get viewport center
      log('\nSTEP 3: Getting viewport center...', 'info');
      const vp = await felt.getViewport();
      const centerLat = vp.center.latitude;
      const centerLng = vp.center.longitude;
      log(`  Center: [${centerLng.toFixed(4)}, ${centerLat.toFixed(4)}]`);
      
      // STEP 4: Test Turf.js point creation
      log('\nSTEP 4: Testing Turf.js...', 'info');
      
      let turfCenterPoint;
      try {
        turfCenterPoint = turf.point([centerLng, centerLat]);
        log(`  âœ… Center point created: ${JSON.stringify(turfCenterPoint.geometry.coordinates)}`, 'success');
      } catch (e) {
        log(`  âŒ turf.point failed for center: ${e.message}`, 'error');
        return;
      }
      
      // Test with first normalized feature
      const testFeature = normalized[0];
      log(`\n  Testing first feature:`, 'info');
      log(`    geometry: ${JSON.stringify(testFeature.geometry)}`);
      log(`    coordinates type: ${typeof testFeature.geometry.coordinates}`);
      log(`    coords[0] type: ${typeof testFeature.geometry.coordinates[0]}`);
      log(`    coords[1] type: ${typeof testFeature.geometry.coordinates[1]}`);
      
      let testPoint;
      try {
        testPoint = turf.point(testFeature.geometry.coordinates);
        log(`  âœ… Feature point created`, 'success');
      } catch (e) {
        log(`  âŒ turf.point failed: ${e.message}`, 'error');
        return;
      }
      
      // Test distance
      try {
        const dist = turf.distance(turfCenterPoint, testPoint, { units: 'kilometers' });
        log(`  âœ… Distance calculated: ${dist.toFixed(2)} km`, 'success');
      } catch (e) {
        log(`  âŒ turf.distance failed: ${e.message}`, 'error');
        return;
      }
      
      // STEP 5: Calculate all distances
      log('\nSTEP 5: Calculating all distances...', 'info');
      const results = [];
      let errors = 0;
      
      for (const feature of normalized) {
        try {
          const pt = turf.point(feature.geometry.coordinates);
          const dist = turf.distance(turfCenterPoint, pt, { units: 'kilometers' });
          results.push({
            name: feature.properties?.place || feature.properties?.acq_date || feature.id,
            distance: dist,
            coords: feature.geometry.coordinates
          });
        } catch (e) {
          errors++;
          if (errors <= 3) log(`  Error on feature: ${e.message}`, 'error');
        }
      }
      
      log(`  âœ… Calculated ${results.length} distances, ${errors} errors`, results.length > 0 ? 'success' : 'error');
      
      // STEP 6: Show results
      results.sort((a, b) => a.distance - b.distance);
      
      log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
      log('    5 NEAREST FEATURES', 'info');
      log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
      
      results.slice(0, 5).forEach((r, i) => {
        log(`${i + 1}. ${r.name}`, 'success');
        log(`   Distance: ${r.distance.toFixed(1)} km`);
        log(`   Coords: [${r.coords[0].toFixed(4)}, ${r.coords[1].toFixed(4)}]`);
      });
      
      // STEP 7: Test buffer
      log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
      log('    BUFFER TEST (1000km)', 'info');
      log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
      
      try {
        const buffer = turf.buffer(turfCenterPoint, 1000, { units: 'kilometers' });
        log(`âœ… Buffer created`, 'success');
        
        let inBuffer = 0;
        for (const feature of normalized) {
          const pt = turf.point(feature.geometry.coordinates);
          if (turf.booleanPointInPolygon(pt, buffer)) {
            inBuffer++;
          }
        }
        
        log(`Features in 1000km buffer: ${inBuffer} / ${normalized.length}`, 'success');
        log(`Percentage: ${((inBuffer / normalized.length) * 100).toFixed(1)}%`);
        
      } catch (e) {
        log(`âŒ Buffer test failed: ${e.message}`, 'error');
      }
      
      log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
      log('    âœ… ALL TESTS COMPLETE', 'success');
      log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
    };
  </script>
</body>
</html>
